# Практическое задание №1
Журавлева Юлия БИСО-01-20

# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования
    R;
2.  Оформить отчет по изученному материалу.

## Исходные данные

1.  ОС Windows 10
2.  RStudio Desktop
3.  Интерпретатор языка R 4.2.2
4.  Библиотека `Swirl`

## План

1.  Установить библиотеку `swirl`
2.  Запустить в консоли `swirl::swirl()`
3.  Пройти 4 урока из 14 предложенных

## Ход выполнения работы

Для начала, установим библиотеку `swirl`. Её можно установить в RStudio
с помощью команды `install.packages("swirl")`.

    install.packages("swirl")

После этого запустим библиотеку с помощью команды `swirl::swirl()`.

    swirl::swirl()

### Урок №1: Основные блоки программирования на языке R

Самая простая форма, которая может использоваться в R - это
интерактивный калькулятор.

``` r
5+7
```

    [1] 12

Чтобы не писать каждый раз одно и то же выражение, можно вынести его в
переменную “x”. После этого запросить вывод этой переменной.

``` r
x<-5+7
x
```

    [1] 12

Далее нужно создать новую переменную “y” и занести туда выражение
`x - 3`. После этого снова запросить вывод этой переменной.

``` r
y <- x - 3
y
```

    [1] 9

Далее создадим вектор через команду `c()` и занесём его в переменную
`z`.

``` r
z <- c(1.1, 9, 3.14)
z
```

    [1] 1.10 9.00 3.14

Если возникнут вопросы по какой-либо команде, всегда можно добавить знак
вопроса (`?`) перед названием команды.

``` r
?c
```

    запускаю httpd сервер помощи... готово

Посмотрим как записался вектор в переменной `z`.

``` r
z
```

    [1] 1.10 9.00 3.14

Можем скомбинировать вектора в один и вывести информацию на экран.
Например, создадим вектор из вектора `z`, 555, `z`.

``` r
c(z, 555, z)
```

    [1]   1.10   9.00   3.14 555.00   1.10   9.00   3.14

``` r
c
```

    function (...)  .Primitive("c")

Также вектора могут использоваться в арифметических выражениях. Умножим
вектор `z` на 2 и прибавим к нему 100. Эти операции будут производиться
с каждым элементом вектора.

``` r
z * 2 + 100
```

    [1] 102.20 118.00 106.28

Наиболее часто встречающиеся операции `+`, `-`, `/`, `*`, `^` могут
прописываться напрямую. Однако чтобы вычислить корень, нужно
использовать команду `sqrt()`, а чтобы взять по модулю - `abs()`.
Попробуем вычислить корень из z - 1 и занести в переменную `my_sqrt`.
Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление
по корню применялось к каждому из них.

``` r
my_sqrt <- sqrt(z - 1)
my_sqrt
```

    [1] 0.3162278 2.8284271 1.4628739

Создадим новую переменную `my_div` и занесём туда результат деления
значений `z` на `my_sqrt`. Затем узнаем что получилось в итоге и
убедимся, что операция выполняется по элементам (т.е. первому элементу
первого вектора соответствует первый элемент второго вектора).

``` r
my_div <- z / my_sqrt
my_div
```

    [1] 3.478505 3.181981 2.146460

Когда вектора равны по длине, то операция вычисляется элемент к
элементу. Но если они разные, то самый короткий вектор повторяется
снова, пока более длинный не закончится. Выведем на экран результат
сложение 2-х векторов: `c(1, 2, 3, 4)` и `c(0, 10)`.

``` r
c(1, 2, 3, 4) + c(0, 10)
```

    [1]  1 12  3 14

В случае, если первый вектор закончился, а второй нет, то перебор
продолжится, то после вывода результата появится предупреждение “Более
длинная длина объекта не кратна более короткой длине объекта”

``` r
c(1, 2, 3, 4) + c(0, 10, 100)
```

    Warning in c(1, 2, 3, 4) + c(0, 10, 100): длина большего объекта не является
    произведением длины меньшего объекта

    [1]   1  12 103   4

Далее рассмотрим лайфхаки, которые сократят время. С помощью стрелок
вверх-вниз можно посмотреть какие команды были ранее. Это поможет при
отладке и просто в случаях, когда надо повторить команду. Найдём
выражение `z * 2 + 100` и поменяем `100` на `1000`.

``` r
z * 2 + 1000
```

    [1] 1002.20 1018.00 1006.28

В случае, если забыли верное название какой-то переменной, то на помощь
придёт `Tab`. Просто нужно ввести первые символы переменной и нажать на
табуляцию, чтобы появился список переменных с таким началом. Найдём
переменную `my_div` по началу `my_` и узнаем её значение.

``` r
my_div
```

    [1] 3.478505 3.181981 2.146460

### Урок №2: Рабочее пространство и файлы

Определим, какой каталог использует текущий сеанс R в качестве текущего
рабочего каталога, используя команду `getwd()`.

``` r
getwd()
```

    [1] "C:/Users/Юлия/Documents/PZ_sem7_7/PZ_1"

Выведем на экран все объекты локальной рабочей среды с помощью команды
`ls()`.”

``` r
ls()
```

    [1] "has_annotations" "my_div"          "my_sqrt"         "x"              
    [5] "y"               "z"              

Назначим 9 в x с помощью команды “x \<- 9”.

``` r
x <- 9
```

Выведем на экран все файлы рабочей директории с помощью команд
“list.files()” или “dir()”.

``` r
dir()
```

    [1] "pppr_1.qmd"       "pppr_1.rmarkdown" "README.md"       

Попробуем функцию вызова информации по команде `list.files`.

``` r
?list.files
```

Используя функцию `args()` мы можем узнать какие аргументы даёт введёная
в скобках функция. Посмотрим аргументы команды `list.files()`

``` r
args(list.files)
```

    function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
        recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
        no.. = FALSE) 
    NULL

Зададим в переменную `old.dir` нашу рабочую директорию. Это нужно, чтобы
в конце к ней вернуться.

``` r
old.dir <- getwd()
old.dir
```

    [1] "C:/Users/Юлия/Documents/PZ_sem7_7/PZ_1"

Посмотрим документацию команды `dir.create` с помощью вопросительного
знака.

``` r
?dir.create
```

С помощью команды `dir.create()` создадим новый директорий с именем
`testdir` в уже существующий. Чтобы работать в этой директории, надо
задать её как рабочую с помощью команды `setwd()`.

Создадим файл `mytest.R`, используя функцию `file.create()` и проверим,
какие файлы у нас лежат в новой директории. Чтобы проверить, существует
ли `mytest.R` в рабочей директории, используем команду `file.exists()`.
Посмотрим информацию о файле `mytest.R`, используя команду
`file.info()`.

Переименуем файл `mytest.R` в `mytest2.R`, используя команду
`file.rename()`. Сделаем копию файла `mytest2.R` и назовём копию
`mytest3.R`, используя команду `file.copy()`. Укажем родительский путь к
файлу `mytest3.R`, используя команду `file.path()`.

Можно использовать `file.path()` для построения путей к файлам и
каталогам, которые не зависят от операционной системы, в которой
выполняется наш R-код. Передадим `folder1` и `folder2` в качестве
аргументов для создания независимого от платформы имени пути.

Создадим новый директорий в нашей рабочей директории и назовём его
`testdir2`, а также создадим сабдиректорий и назовём его `testdir3`,
используя только команды `dir.create()` и `file.path()`. Вернёмся
обратно в рабочую директорию на компьютере, с помощью команды `setwd()`.
Вспомним, что ранее мы заносили её в переменную `old.dir`.

``` r
dir.create("testdir")
setwd("testdir")
getwd()
```

    [1] "C:/Users/Юлия/Documents/PZ_sem7_7/PZ_1/testdir"

``` r
file.create("mytest.R")
```

    [1] TRUE

``` r
dir()
```

    [1] "mytest.R"

``` r
file.exists("mytest.R")
```

    [1] TRUE

``` r
file.info("mytest.R")
```

             size isdir mode               mtime               ctime
    mytest.R    0 FALSE  666 2023-12-17 02:54:08 2023-12-17 02:54:08
                           atime exe
    mytest.R 2023-12-17 02:54:08  no

``` r
file.rename("mytest.R", "mytest2.R")
```

    [1] TRUE

``` r
file.copy("mytest2.R", "mytest3.R")
```

    [1] TRUE

``` r
file.path("mytest3.R")
```

    [1] "mytest3.R"

``` r
file.path("folder1", "folder2")
```

    [1] "folder1/folder2"

``` r
dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE)
setwd(old.dir)
```

### Урок №3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать
оператор `:`. Введём `1:20`, чтобы увидеть как это работает.

``` r
1:20
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Также мы можем создать последовательность из вещественных чисел. Для
этого используем команду `pi:10`, чтобы создать последовательность от
числа Пи.

``` r
pi:10
```

    [1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

Если поменять цифры местами, то получится обратный список
последовательности чисел. Попробуем перевернуть список с помощью команды
`15:1`.

``` r
15:1
```

     [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

Важно помнить, что при запросе документации по оператору, его необходимо
заключить в `подобные` кавычки. Попробуем узнать информацию об операторе
`?`.

``` r
?`:`
```

Существует операция `seq()`, аналогичная оператору `:`. Убедимся в этом
с помощью команды `seq(1, 20)`.

``` r
seq(1, 20)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Можно задать последовательность чисел и указать шаг, на который будет
сдвигаться генерация чисел. Создадим последовательность от 0 до 10 с
шагом 0.5 с помощью команды `seq(0, 20, by=0.5)`.

``` r
seq(0, 10, by=0.5)
```

     [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0
    [16]  7.5  8.0  8.5  9.0  9.5 10.0

Если нас не волнует, какое приращение задано и мы просто хотим создать
последовательность от 5 до 10, которое включает в себя 30 элементов.
Создадим данную последовательность через команду `seq(5, 10, length=30)`
и занесём её в переменную `my_seq`.

``` r
my_seq <- seq(5, 10, length=30)
my_seq
```

     [1]  5.000000  5.172414  5.344828  5.517241  5.689655  5.862069  6.034483
     [8]  6.206897  6.379310  6.551724  6.724138  6.896552  7.068966  7.241379
    [15]  7.413793  7.586207  7.758621  7.931034  8.103448  8.275862  8.448276
    [22]  8.620690  8.793103  8.965517  9.137931  9.310345  9.482759  9.655172
    [29]  9.827586 10.000000

Чтобы убедиться, что последовательность имеет длину 30, ипользуем
команду `length()`.

``` r
length(my_seq)
```

    [1] 30

Теперь посмотрим как мы можем комбинировать команды между собой.
Используем значение длины 30 и попробуем задать последовательность
`1:30` с использованием команды `length(my_seq)`.

``` r
1:length(my_seq)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    [26] 26 27 28 29 30

Есть и другой вариант использования данной конструкции, используя
функцию `along.with`, которая берет длину из длины аргумента (замена
length()).

``` r
seq(along.with = my_seq)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    [26] 26 27 28 29 30

Однако, как и в случае со многими распространенными задачами, R имеет
отдельную встроенную функцию для этой цели, называемую `seq_along()`.
Она составляет на основе длины последловательности свою собственную.

``` r
seq_along(my_seq)
```

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    [26] 26 27 28 29 30

Также существует функция повторения числа или вектора n-ное количество
раз. Создадим вектор, который содержит в себе 40 нулей с помощью команды
`rep(0, times = 40)`.

``` r
rep(0, times = 40)
```

     [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    [39] 0 0

Посмотрим как эта же функция можем справиться с векторами, созданными
через функцию `c(0, 1, 2)`. Повторим её 10 раз с помощью команды
`rep(c(0, 1, 2), times = 10)`.

``` r
rep(c(0, 1, 2), times = 10)
```

     [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

Стоит отметить, что если нам требуется повторить каждый элемент, то на
помощь придёт функция `each()`. Попробуем повторить 10 раз каждый из
элементов вектора `c(0, 1, 2)` с помощью команды
`rep(c(0, 1, 2), each = 10)`.

``` r
rep(c(0, 1, 2), each = 10)
```

     [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

### Урок №4: Векторы

Начнём с создания вектора чисел, который содержит значения `0.5`, `55`,
`-10`, `6` и занесён в переменную `num_vect`.

``` r
num_vect <- c(0.5, 55, -10, 6)
num_vect
```

    [1]   0.5  55.0 -10.0   6.0

Далее создадим новую переменную `tf` и дадим ей значение результата
`num_vect < 1`. В итоге мы получим вектор, содержащий 4 логических
значения \[TRUE | FALSE\]. Выведем на экран значение переменной `tf`.

``` r
tf <- num_vect < 1
tf
```

    [1]  TRUE FALSE  TRUE FALSE

Далее выведем на экран результат работы команды `num_vect >= 6` без
занесения в переменную.

``` r
num_vect >= 6
```

    [1] FALSE  TRUE FALSE  TRUE

Далее необходимо пройти мини-тест, содержащий в себе 2 варианта ответа.

#### Вопрос №1.

``` r
(3 > 5) & (4 == 4)
```

    [1] FALSE

#### Вопрос №2.

``` r
(TRUE == TRUE) | (TRUE == FALSE)
```

    [1] TRUE

#### Вопрос №3.

``` r
((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
```

    [1] TRUE

Вектора могут состоять не только из чисел, но и из символов. Для того,
чтобы задать в вектор символьные элементы, необходимо использовать
двойные кавычки-лапки `""`, чтобы обозначить строковый элемент. Зададим
вектор, состоящий из 3-х слов “My”, “name”, “is” и занесём его в
переменную `my_char`. Выведем на экран значение вектора `my_char`.

``` r
my_char <- c("My", "name", "is")
my_char
```

    [1] "My"   "name" "is"  

Сейчас этот вектор имеет длину 3. Соединим его в один с помощью команды
`paste()` и добавим пробел, который будет соединять элементы
`collapse = " "`, а затем выведем всё на экран.

``` r
paste(my_char, collapse = " ")
```

    [1] "My name is"

Осталось только создать новый вектор и добавить туда своё имя. Создадим
новую переменную `my_name` и занесём туда новый результат. Выведем на
экран значение переменной `my_name`.

``` r
my_name <- c(my_char, "Yuliya")
my_name
```

    [1] "My"     "name"   "is"     "Yuliya"

Так как вектор записался по элементам, его нужно соединить, добавив
пробел между ними.

``` r
paste(my_name, collapse = " ")
```

    [1] "My name is Yuliya"

Рассмотрим другой вариант - добавление соединяющего символа (пробела)
при объединении других с помощью команды `sep = " "`. Соединим слова
“Hello” и “world!”, добавив пробел между ними и выведем это на экран.

``` r
paste("Hello", "world!", sep = " ")
```

    [1] "Hello world!"

Рассмотрим вариант соединения двух векторов в один. Соединим вектор от 1
до 3 с вектором (“X”, “Y”, “Z”), не используя пробел как соединитель
между элементами.

``` r
paste(1:3, c("X","Y","Z"), sep = "")
```

    [1] "1X" "2Y" "3Z"

Если вектора имеют разную длину, то меньший вектор повторяется снова,
пока больший не закончится. Попробуем перебрать и соединить все буквы
латинского алфавита с вектором от 1 до 4, используя соединитель
`sep = "-"`. Команда `LETTERS` автоматически перебирает все буквы, без
нужды указывать каждую.

``` r
paste(LETTERS, 1:4, sep = "-")
```

     [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4"
    [13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
    [25] "Y-1" "Z-2"

## Оценка результатов

Пройдено 4 урока из интерактивного курса Swirl по основам языка R.

## Вывод

В результате выполнения практической работы были получены базовые навыки
программирования на языке R.
