---
title: "Практическое задание №1"
author: "Журавлева Юлия БИСО-01-20"
format: 
  md:
    output-file: README.md
---
# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования R;
2.  Оформить отчет по изученному материалу.

## Исходные данные

1.  ОС Windows 10
2.  RStudio Desktop
3.  Интерпретатор языка R 4.2.2
4.  Библиотека `Swirl`

## План

1. Установить библиотеку `swirl`
2. Запустить в консоли `swirl::swirl()`
3. Пройти 4 урока из 14 предложенных

## Ход выполнения работы

Для начала, установим библиотеку `swirl`. Её можно установить в RStudio с помощью команды `install.packages("swirl")`. После этого запустим библиотеку с помощью команды `swirl::swirl()`.

```{r}
install.packages("swirl")
swirl::swirl()
```

### Урок №1: Основные блоки программирования на языке R

Самая простая форма, которая может использоваться в R - это интерактивный калькулятор.

```{r}
5+7
```

Чтобы не писать каждый раз одно и то же выражение, можно вынести его в переменную "x". После этого запросить вывод этой переменной.

```{r}
x<-5+7
x
```

Далее нужно создать новую переменную "y" и занести туда выражение `x - 3`. После этого снова запросить вывод этой переменной.

```{r}
y <- x - 3
y
```

Далее создадим вектор через команду `c()` и занесём его в переменную `z`.

```{r}
z <- c(1.1, 9, 3.14)
z
```

Если возникнут вопросы по какой-либо команде, всегда можно добавить знак вопроса (`?`) перед названием команды. 

```{r}
?c
```

Посмотрим как записался вектор в переменной `z`.

```{r}
z
```

Можем скомбинировать вектора в один и вывести информацию на экран. Например, создадим вектор из вектора `z`, 555, `z`. 

```{r}
c(z, 555, z)
c
```

Также вектора могут использоваться в арифметических выражениях. Умножим вектор `z` на 2 и прибавим к нему 100. Эти операции будут производиться с каждым элементом вектора.

```{r}
z * 2 + 100
```

Наиболее часто встречающиеся операции `+`, `-`, `/`, `*`, `^` могут прописываться напрямую. Однако чтобы вычислить корень, нужно использовать команду `sqrt()`, а чтобы взять по модулю - `abs()`. Попробуем вычислить корень из z - 1 и занести в переменную `my_sqrt`. Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление по корню применялось к каждому из них.

```{r}
my_sqrt <- sqrt(z - 1)
my_sqrt
```

Создадим новую переменную `my_div` и занесём туда результат деления значений `z` на `my_sqrt`. Затем узнаем что получилось в итоге и убедимся, что операция выполняется по элементам (т.е. первому элементу первого вектора соответствует первый элемент второго вектора).

```{r}
my_div <- z / my_sqrt
my_div
```

Когда вектора равны по длине, то операция вычисляется элемент к элементу. Но если они разные, то самый короткий вектор повторяется снова, пока более длинный не закончится. Выведем на экран результат сложение 2-х векторов: `c(1, 2, 3, 4)` и `c(0, 10)`.

```{r}
c(1, 2, 3, 4) + c(0, 10)
```

В случае, если первый вектор закончился, а второй нет, то перебор продолжится, то после вывода результата появится предупреждение "Более длинная длина объекта не кратна более короткой длине объекта"

```{r}
c(1, 2, 3, 4) + c(0, 10, 100)
```

Далее рассмотрим лайфхаки, которые сократят время. С помощью стрелок вверх-вниз можно посмотреть какие команды были ранее. Это поможет при отладке и просто в случаях, когда надо повторить команду. Найдём выражение `z * 2 + 100` и поменяем `100` на `1000`.

```{r}
z * 2 + 1000
```

В случае, если забыли верное название какой-то переменной, то на помощь придёт `Tab`. Просто нужно ввести первые символы переменной и нажать на табуляцию, чтобы появился список переменных с таким началом. Найдём переменную `my_div` по началу `my_` и узнаем её значение.

```{r}
my_div
```

### Урок №2: Рабочее пространство и файлы

Определим, какой каталог использует текущий сеанс R в качестве текущего рабочего каталога, используя команду `getwd()`.

```{r}
getwd()
```

Выведем на экран все объекты локальной рабочей среды с помощью команды `ls()`."

```{r}
ls()
```

Назначим 9 в x с помощью команды "x <- 9".

```{r}
x <- 9
```

Выведем на экран все файлы рабочей директории с помощью команд "list.files()" или "dir()".

```{r}
dir()
```

Попробуем функцию вызова информации по команде `list.files`.

```{r}
?list.files
```

Используя функцию `args()` мы можем узнать какие аргументы даёт введёная в скобках функция. Посмотрим аргументы команды `list.files()`

```{r}
args(list.files)
```

Зададим в переменную `old.dir` нашу рабочую директорию. Это нужно, чтобы в конце к ней вернуться.

```{r}
old.dir <- getwd()
old.dir
```

С помощью команды `dir.create()` создадим новый директорий с именем `testdir` в уже существующий.

```{r}
dir.create("testdir")
```

Чтобы работать в этой директории, надо задать её как рабочую с помощью команды `setwd()`.

```{r}
setwd("testdir")
```

Создадим файл `mytest.R`, используя функцию `file.create()`.

```{r}
file.create("mytest.R")
```

Проверим, какие файлы у нас лежат в новой директории.

```{r}
dir()
```

Чтобы проверить, существует ли `mytest.R` в рабочей директории, используем команду `file.exists()`.

```{r}
file.exists("mytest.R")
```

Посмотрим информацию о файле `mytest.R`, используя команду `file.info()`.

```{r}
file.info("mytest.R")
```

Переименуем файл `mytest.R` в `mytest2.R`, используя команду `file.rename()`.

```{r}
file.rename("mytest.R", "mytest2.R")
```

Сделаем копию файла `mytest2.R` и назовём копию `mytest3.R`, используя команду `file.copy()`.

```{r}
file.copy("mytest2.R", "mytest3.R")
```

Укажите родительский путь к файлу `mytest3.R`, используя команду `file.path()`.
```{r}
file.path("mytest3.R")
```

Можно использовать `file.path()` для построения путей к файлам и каталогам, которые не зависят от операционной системы, в которой выполняется наш R-код. Передадим `folder1` и `folder2` в качестве аргументов для создания независимого от платформы имени пути.

```{r}
file.path("folder1", "folder2")
```

Посмотрим документацию команды `dir.create` с помощью вопросительного знака.

```{r}
?dir.create
```

Создадим новый директорий в нашей рабочей директории и назовём его `testdir2`, а также создадим сабдиректорий и назовём его `testdir3`, используя только команды `dir.create()` и `file.path()`.

```{r}
dir.create(file.path(`testdir2`, `testdir3`), recursive = TRUE)
```

Вернёмся обратно в рабочую директорию на компьютере, с помощью команды `setwd()`. Вспомним, что ранее мы заносили её в переменную `old.dir`.

```{r}
setwd(old.dir)
```

### Урок №3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать оператор `:`. Введём `1:20`, чтобы увидеть как это работает.

```{r}
1:20
```

Также мы можем создать последовательность из вещественных чисел. Для этого используем команду `pi:10`, чтобы создать последовательность от числа Пи.

```{r}
pi:10
```

Если поменять цифры местами, то получится обратный список последовательности чисел. Попробуем перевернуть список с помощью команды `15:1`.

```{r}
15:1
```

Важно помнить, что при запросе документации по оператору, его необходимо заключить в ``подобные`` кавычки. Попробуем узнать информацию об операторе `?`.

```{r}
?`:`
```

Существует операция `seq()`, аналогичная оператору `:`. Убедимся в этом с помощью команды `seq(1, 20)`.

```{r}
seq(1, 20)
```

Можно задать последовательность чисел и указать шаг, на который будет сдвигаться генерация чисел. Создадим последовательность от 0 до 10 с шагом 0.5 с помощью команды `seq(0, 20, by=0.5)`.

```{r}
seq(0, 10, by=0.5)
```

Если нас не волнует, какое приращение задано и мы просто хотим создать последовательность от 5 до 10, которое включает в себя 30 элементов. Создадим данную последовательность через команду `seq(5, 10, length=30)` и занесём её в переменную `my_seq`.

```{r}
my_seq <- seq(5, 10, length=30)
my_seq
```

Чтобы убедиться, что последовательность имеет длину 30, ипользуем команду `length()`.

```{r}
length(my_seq)
```

Теперь посмотрим как мы можем комбинировать команды между собой. Используем значение длины 30 и попробуем задать последовательность `1:30` с использованием команды `length(my_seq)`.

```{r}
1:length(my_seq)
```

Есть и другой вариант использования данной конструкции, используя функцию `along.with`, которая берет длину из длины аргумента (замена length()).

```{r}
seq(along.with = my_seq)
```

Однако, как и в случае со многими распространенными задачами, R имеет отдельную встроенную функцию для этой цели, называемую `seq_along()`. Она составляет на основе длины последловательности свою собственную.

```{r}
seq_along(my_seq)
```

Также существует функция повторения числа или вектора n-ное количество раз. Создадим вектор, который содержит в себе 40 нулей с помощью команды `rep(0, times = 40)`.

```{r}
rep(0, times = 40)
```

Посмотрим как эта же функция можем справиться с векторами, созданными через функцию `c(0, 1, 2)`. Повторим её 10 раз с помощью команды `rep(c(0, 1, 2), times = 10)`.

```{r}
rep(c(0, 1, 2), times = 10)
```

Стоит отметить, что если нам требуется повторить каждый элемент, то на помощь придёт функция `each()`. Попробуем повторить 10 раз каждый из элементов вектора `c(0, 1, 2)` с помощью команды `rep(c(0, 1, 2), each = 10)`.

```{r}
rep(c(0, 1, 2), each = 10)
```

### Урок №4: Векторы

Начнём с создания вектора чисел, который содержит значения `0.5`, `55`, `-10`, `6` и занесён в переменную `num_vect`.

```{r}
num_vect <- c(0.5, 55, -10, 6)
num_vect
```

Далее создадим новую переменную `tf` и дадим ей значение результата `num_vect < 1`. В итоге мы получим вектор, содержащий 4 логических значения [TRUE | FALSE]. Выведем на экран значение переменной `tf`.

```{r}
tf <- num_vect < 1
tf
```

Далее выведем на экран результат работы команды `num_vect >= 6` без занесения в переменную.

```{r}
num_vect >= 6
```

Далее необходимо пройти мини-тест, содержащий в себе 2 варианта ответа.

#### Вопрос №1.

```{r}
(3 > 5) & (4 == 4)
```

#### Вопрос №2.

```{r}
(TRUE == TRUE) | (TRUE == FALSE)
```

#### Вопрос №3.

```{r}
((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
```

Вектора могут состоять не только из чисел, но и из символов. Для того, чтобы задать в вектор символьные элементы, необходимо использовать двойные кавычки-лапки `""`, чтобы обозначить строковый элемент. Зададим вектор, состоящий из 3-х слов "My", "name", "is" и занесём его в переменную `my_char`. Выведем на экран значение вектора `my_char`.

```{r}
my_char <- c("My", "name", "is")
my_char
```

Сейчас этот вектор имеет длину 3. Соединим его в один с помощью команды `paste()` и добавим пробел, который будет соединять элементы `collapse = " "`, а затем выведем всё на экран.

```{r}
paste(my_char, collapse = " ")
```

Осталось только создать новый вектор и добавить туда своё имя. Создадим новую переменную `my_name` и занесём туда новый результат. Выведем на экран значение переменной `my_name`.

```{r}
my_name <- c(my_char, "Yuliya")
my_name
```

Так как вектор записался по элементам, его нужно соединить, добавив пробел между ними.

```{r}
paste(my_name, collapse = " ")
```

Рассмотрим другой вариант - добавление соединяющего символа (пробела) при объединении других с помощью команды `sep = " "`. Соединим слова "Hello" и "world!", добавив пробел между ними и выведем это на экран.

```{r}
paste("Hello", "world!", sep = " ")
```

Рассмотрим вариант соединения двух векторов в один. Соединим вектор от 1 до 3 с вектором ("X", "Y", "Z"), не используя пробел как соединитель между элементами.

```{r}
paste(1:3, c("X","Y","Z"), sep = "")
```

Если вектора имеют разную длину, то меньший вектор повторяется снова, пока больший не закончится. Попробуем перебрать и соединить все буквы латинского алфавита с вектором от 1 до 4, используя соединитель `sep = "-"`. Команда `LETTERS` автоматически перебирает все буквы, без нужды указывать каждую.

```{r}
paste(LETTERS, 1:4, sep = "-")
```

## Оценка результатов

Пройдено 4 урока из интерактивного курса Swirl по основам языка R.

## Вывод

В результате выполнения практической работы были получены базовые навыки программирования на языке R.