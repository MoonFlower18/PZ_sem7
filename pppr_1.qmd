---
title: "Практическое задание №1"
author: "Журавлева Юлия БИСО-01-20"
format: 
  md:
    output-file: PZ_1.md
---
# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования R;
2.  Оформить отчет по изученному материалу.

## Ход выполнения работы

Для начала загрузим пакет Swirl, выберем его во вкладке Packages и введём в строку команду `swirl()`. Далее выбираем курс R Programming и попадаем на список уроков, которые требуется сделать. Всего их 14, в рамках работы надо сделать 4 урока. 

### Урок №1: Основные блоки программирования на языке R

Самая простая форма, которая может использоваться в R - это интерактивный калькулятор.

```
> 5+7

[1] 12
```

Чтобы не писать каждый раз одно и то же выражение, можно вынести его в переменную "x". После этого запросить вывод этой переменной.

```
> x<-5+7
> x

[1] 12
```

Далее нужно создать новую переменную "y" и занести туда выражение 'x - 3'. После этого снова запросить вывод этой переменной.

```
> y <- x - 3
> y

[1] 9
```

Далее создадим вектор через команду 'c()' и занесём его в переменную 'z'.

```
> z <- c(1.1, 9, 3.14)
```

Если возникнут вопросы по какой-либо команде, всегда можно добавить знак вопроса ('?') перед названием команды. 

```
> ?c
```

Посмотрим как записался вектор в переменной 'z'.

```
> z

[1] 1.10 9.00 3.14
```

Можем скомбинировать вектора в один и вывести информацию на экран. Например, создадим вектор из вектора 'z', 555, 'z'. 

```
> c(z, 555, z)

[1]   1.10   9.00   3.14 555.00   1.10   9.00   3.14
```

Также вектора могут использоваться в арифметических выражениях. Умножим вектор 'z' на 2 и прибавим к нему 100. Эти операции будут производиться с каждым элементом вектора.

```
> z * 2 + 100

[1] 102.20 118.00 106.28
```

Наиболее часто встречающиеся операции '+', '-', '/', '*', '^' могут прописываться напрямую. Однако чтобы вычислить корень, нужно использовать команду 'sqrt()', а чтобы взять по модулю - 'abs()'. Попробуем вычислить корень из z - 1 и занести в переменную 'my_sqrt'. Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление по корню применялось к каждому из них.

```
> my_sqrt <- sqrt(z - 1)
> my_sqrt

[1] 0.3162278 2.8284271 1.4628739
```

Создадим новую переменную 'my_div' и занесём туда результат деления значений 'z' на 'my_sqrt'. Затем узнаем что получилось в итоге и убедимся, что операция выполняется по элементам (т.е. первому элементу первого вектора соответствует первый элемент второго вектора).
```
> my_div <- z / my_sqrt
> my_div

[1] 3.478505 3.181981 2.146460
```
Когда вектора равны по длине, то операция вычисляется элемент к элементу. Но если они разные, то самый короткий вектор повторяется снова, пока более длинный не закончится. Выведем на экран результат сложение 2-х векторов: 'c(1, 2, 3, 4)' и 'c(0, 10)'.

```
> c(1, 2, 3, 4) + c(0, 10)

[1]  1 12  3 14
```

В случае, если первый вектор закончился, а второй нет, то перебор продолжится, то после вывода результата появится предупреждение "Более длинная длина объекта не кратна более короткой длине объекта"

```
> c(1, 2, 3, 4) + c(0, 10, 100)

[1]   1  12 103   4

Warning message:
In c(1, 2, 3, 4) + c(0, 10, 100) :
  longer object length is not a multiple of shorter object length
```

Далее рассмотрим лайфхаки, которые сократят время. С помощью стрелок вверх-вниз можно посмотреть какие команды были ранее. Это поможет при отладке и просто в случаях, когда надо повторить команду. Найдём выражение 'z * 2 + 100' и поменяем '100' на '1000'.

``` 
> z * 2 + 1000

[1] 1002.20 1018.00 1006.28
```

В случае, если забыли верное название какой-то переменной, то на помощь придёт 'Tab'. Просто нужно ввести первые символы переменной и нажать на табуляцию, чтобы появился список переменных с таким началом. Найдём переменную 'my_div' по началу 'my_' и узнаем её значение.

```
> my_div

[1] 3.478505 3.181981 2.146460
```

### Урок №2: Рабочее пространство и файлы

Определим, какой каталог использует текущий сеанс R в качестве текущего рабочего каталога, используя команду 'getwd()'.

```
> getwd()

[1] "C:/Users/Юлия/Documents/PZ_sem7_7"
```

Выведем на экран все объекты локальной рабочей среды с помощью команды 'ls()'. Так как переменных изначально не было, на экран вывело "character(0)"

```
> ls()

character(0)
```
Назначим 9 в x с помощью команды "x <- 9".

```
> x <- 9
```

Теперь посмотрим на объекты локальной рабочей среды с помощью команды "ls()".

```
> ls()

[1] "x"
```

Выведем на экран все файлы рабочей директории с помощью команд "list.files()" или "dir()".                               

```
> dir()

[1] "pppr_1.html"     "pppr_1.qmd"      "pppr_1_files"    "PZ_1"           
[5] "PZ_1.md"         "PZ_sem7_2.Rproj" "README.md"       "testdir"  
```

Попробуем функцию вызова информации по команде 'list.files'.

```
> ?list.files
```

Используя функцию 'args()' мы можем узнать какие аргументы даёт введёная в скобках функция. Посмотрим аргументы команды 'list.files()'

```
> args(list.files)
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
NULL
```

Зададим в переменную 'old.dir' нашу рабочую директорию. Это нужно, чтобы в конце к ней вернуться.

```
> old.dir <- getwd()
```

С помощью команды 'dir.create()' создадим новый директорий с именем 'testdir' в уже существующий. Так как он был создан ранее, то программа выдаст предупреждение.

```
> dir.create("testdir")

Warning message:
In dir.create("testdir") : 'testdir' already exists
```

Чтобы работать в этой директории, надо задать её как рабочую с помощью команды 'setwd()'.

```
> setwd("testdir")
```

Создадим файл 'mytest.R', используя функцию 'file.create()'.

```
> file.create("mytest.R")

[1] TRUE
```

Проверим, какие файлы у нас лежат в новой директории.

```
> dir()

[1] "mytest.R"
```

Чтобы проверить, существует ли 'mytest.R' в рабочей директории, используем команду 'file.exists()'.

```
> file.exists("mytest.R")

[1] TRUE
```

Посмотрим информацию о файле 'mytest.R', используя команду 'file.info()'.

```
> file.info("mytest.R")

         size isdir mode               mtime               ctime
mytest.R    0 FALSE  666 2023-09-30 11:36:47 2023-09-28 15:47:09
                       atime exe
mytest.R 2023-09-30 11:36:47  no
```

Переименуем файл 'mytest.R' в 'mytest2.R', используя команду 'file.rename()'.

```
> file.rename("mytest.R", "mytest2.R")

[1] TRUE
```

Сделаем копию файла 'mytest2.R' и назовём копию 'mytest3.R', используя команду 'file.copy()'.

```
> file.copy("mytest2.R", "mytest3.R")

[1] TRUE
```

Укажите родительский путь к файлу 'mytest3.R', используя команду 'file.path()'.

```
> file.path("mytest3.R")

[1] "mytest3.R"
```

Можно использовать 'file.path()' для построения путей к файлам и каталогам, которые не зависят от операционной системы, в которой выполняется наш R-код. Передадим 'folder1' и 'folder2' в качестве аргументов для создания независимого от платформы имени пути.

```
> file.path("folder1", "folder2")

[1] "folder1/folder2"
```

Посмотрим документацию команды 'dir.create' с помощью вопросительного знака.

```
> ?dir.create
```

Создадим новый директорий в нашей рабочей директории и назовём его 'testdir2', а также создадим сабдиректорий и назовём его 'testdir3', используя только команды 'dir.create()' и 'file.path()'.

```
> dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE)
```

Вернёмся обратно в рабочую директорию на компьютере, с помощью команды 'setwd()'. Вспомним, что ранее мы заносили её в переменную 'old.dir'.

```
> setwd(old.dir)
```

### Урок №3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать оператор ':'. Введём '1:20', чтобы увидеть как это работает.

```
> 1:20

 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
```

Также мы можем создать последовательность из вещественных чисел. Для этого используем команду 'pi:10', чтобы создать последовательность от числа Пи.

```
> pi:10

[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593
```

Если поменять цифры местами, то получится обратный список последовательности чисел. Попробуем перевернуть список с помощью команды '15:1'.

```
> 15:1

 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
```

Важно помнить, что при запросе документации по оператору, его необходимо заключить в '`подобные`' кавычки. Попробуем узнать информацию об операторе '?'.

```
> ?`:`
```

| You got it!

  |=======================                                          |  35%
| Often, we'll desire more control over a sequence we're creating than
| what the `:` operator gives us. The seq() function serves this purpose.

...

  |=========================                                        |  39%
| The most basic use of seq() does exactly the same thing as the `:`
| operator. Try seq(1, 20) to see this.

> seq(1, 20)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| Your dedication is inspiring!

  |============================                                     |  43%
| This gives us the same output as 1:20. However, let's say that instead
| we want a vector of numbers ranging from 0 to 10, incremented by 0.5.
| seq(0, 10, by=0.5) does just that. Try it out.

> seq(0, 20, by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5
[15]  7.0  7.5  8.0  8.5  9.0  9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5
[29] 14.0 14.5 15.0 15.5 16.0 16.5 17.0 17.5 18.0 18.5 19.0 19.5 20.0

| Nice try, but that's not exactly what I was hoping for. Try again. Or,
| type info() for more options.

| You are still using the seq() function here, but this time with an extra
| argument that tells R you want to increment your sequence by 0.5. Try
| seq(0, 10, by=0.5).

> seq(0, 10, by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5
[15]  7.0  7.5  8.0  8.5  9.0  9.5 10.0

| Nice work!

  |===============================                                  |  48%
| Or maybe we don't care what the increment is and we just want a sequence
| of 30 numbers between 5 and 10. seq(5, 10, length=30) does the trick.
| Give it a shot now and store the result in a new variable called my_seq.

> 
> my_seq <- seq(5, 10, length=30)

| You are doing so well!

  |==================================                               |  52%
| To confirm that my_seq has length 30, we can use the length() function.
| Try it now.

> length("my_seq")
[1] 1

| Try again. Getting it right on the first try is boring anyway! Or, type
| info() for more options.

| Use length(my_seq) to view the length of the my_seq variable.

> length(my_seq)
[1] 30

| That's a job well done!

  |=====================================                            |  57%
| Let's pretend we don't know the length of my_seq, but we want to
| generate a sequence of integers from 1 to N, where N represents the
| length of the my_seq vector. In other words, we want a new vector (1, 2,
| 3, ...) that is the same length as my_seq.

...

  |========================================                         |  61%
| There are several ways we could do this. One possibility is to combine
| the `:` operator and the length() function like this: 1:length(my_seq).
| Give that a try.

> 1:length(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25 26 27 28 29 30

| All that hard work is paying off!

  |==========================================                       |  65%
| Another option is to use seq(along.with = my_seq). Give that a try.

> seq(along.with = my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25 26 27 28 29 30

| You are quite good my friend!

  |=============================================                    |  70%
| However, as is the case with many common tasks, R has a separate
| built-in function for this purpose called seq_along(). Type
| seq_along(my_seq) to see it in action.

> seq_along(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25 26 27 28 29 30

| You're the best!

  |================================================                 |  74%
| There are often several approaches to solving the same problem,
| particularly in R. Simple approaches that involve less typing are
| generally best. It's also important for your code to be readable, so
| that you and others can figure out what's going on without too much
| hassle.

...

  |===================================================              |  78%
| If R has a built-in function for a particular task, it's likely that
| function is highly optimized for that purpose and is your best option.
| As you become a more advanced R programmer, you'll design your own
| functions to perform tasks when there are no better options. We'll
| explore writing your own functions in future lessons.

...

  |======================================================           |  83%
| One more function related to creating sequences of numbers is rep(),
| which stands for 'replicate'. Let's look at a few uses.

...

  |=========================================================        |  87%
| If we're interested in creating a vector that contains 40 zeros, we can
| use rep(0, times = 40). Try it out.

> rep(0, times = 40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[36] 0 0 0 0 0

| Keep up the great work!

  |===========================================================      |  91%
| If instead we want our vector to contain 10 repetitions of the vector
| (0, 1, 2), we can do rep(c(0, 1, 2), times = 10). Go ahead.

> rep(c(0, 1, 2), times = 10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

| Keep working like that and you'll get there!

  |==============================================================   |  96%
| Finally, let's say that rather than repeating the vector (0, 1, 2) over
| and over again, we want our vector to contain 10 zeros, then 10 ones,
| then 10 twos. We can do this with the `each` argument. Try rep(c(0, 1,
| 2), each = 10).

> rep(c(0, 1, 2), each = 10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

| You are quite good my friend!

### Векторы

ааааа
