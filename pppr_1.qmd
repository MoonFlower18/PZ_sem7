---
title: "Практическое задание №1"
author: "Журавлева Юлия БИСО-01-20"
format: 
  md:
    output-file: PZ_1.md
---
# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования R;
2.  Оформить отчет по изученному материалу.

## Ход выполнения работы

Для начала загрузим пакет Swirl, выберем его во вкладке Packages и введём в строку команду `swirl()`. Далее выбираем курс R Programming и попадаем на список уроков, которые требуется сделать. Всего их 14, в рамках работы надо сделать 4 урока. 

### Урок №1: Основные блоки программирования на языке R

Самая простая форма, которая может использоваться в R - это интерактивный калькулятор.

```
> 5+7

[1] 12
```

Чтобы не писать каждый раз одно и то же выражение, можно вынести его в переменную "x". После этого запросить вывод этой переменной.

```
> x<-5+7
> x

[1] 12
```

Далее нужно создать новую переменную "y" и занести туда выражение `x - 3`. После этого снова запросить вывод этой переменной.

```
> y <- x - 3
> y

[1] 9
```

Далее создадим вектор через команду `c()` и занесём его в переменную `z`.

```
> z <- c(1.1, 9, 3.14)
```

Если возникнут вопросы по какой-либо команде, всегда можно добавить знак вопроса (`?`) перед названием команды. 

```
> ?c
```

Посмотрим как записался вектор в переменной `z`.

```
> z

[1] 1.10 9.00 3.14
```

Можем скомбинировать вектора в один и вывести информацию на экран. Например, создадим вектор из вектора `z`, 555, `z`. 

```
> c(z, 555, z)

[1]   1.10   9.00   3.14 555.00   1.10   9.00   3.14
```

Также вектора могут использоваться в арифметических выражениях. Умножим вектор `z` на 2 и прибавим к нему 100. Эти операции будут производиться с каждым элементом вектора.

```
> z * 2 + 100

[1] 102.20 118.00 106.28
```

Наиболее часто встречающиеся операции `+`, `-`, `/`, `*`, `^` могут прописываться напрямую. Однако чтобы вычислить корень, нужно использовать команду `sqrt()`, а чтобы взять по модулю - `abs()`. Попробуем вычислить корень из z - 1 и занести в переменную `my_sqrt`. Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление по корню применялось к каждому из них.

```
> my_sqrt <- sqrt(z - 1)
> my_sqrt

[1] 0.3162278 2.8284271 1.4628739
```

Создадим новую переменную `my_div` и занесём туда результат деления значений `z` на `my_sqrt`. Затем узнаем что получилось в итоге и убедимся, что операция выполняется по элементам (т.е. первому элементу первого вектора соответствует первый элемент второго вектора).
```
> my_div <- z / my_sqrt
> my_div

[1] 3.478505 3.181981 2.146460
```
Когда вектора равны по длине, то операция вычисляется элемент к элементу. Но если они разные, то самый короткий вектор повторяется снова, пока более длинный не закончится. Выведем на экран результат сложение 2-х векторов: `c(1, 2, 3, 4)` и `c(0, 10)`.

```
> c(1, 2, 3, 4) + c(0, 10)

[1]  1 12  3 14
```

В случае, если первый вектор закончился, а второй нет, то перебор продолжится, то после вывода результата появится предупреждение "Более длинная длина объекта не кратна более короткой длине объекта"

```
> c(1, 2, 3, 4) + c(0, 10, 100)

[1]   1  12 103   4

Warning message:
In c(1, 2, 3, 4) + c(0, 10, 100) :
  longer object length is not a multiple of shorter object length
```

Далее рассмотрим лайфхаки, которые сократят время. С помощью стрелок вверх-вниз можно посмотреть какие команды были ранее. Это поможет при отладке и просто в случаях, когда надо повторить команду. Найдём выражение `z * 2 + 100` и поменяем `100` на `1000`.

``` 
> z * 2 + 1000

[1] 1002.20 1018.00 1006.28
```

В случае, если забыли верное название какой-то переменной, то на помощь придёт `Tab`. Просто нужно ввести первые символы переменной и нажать на табуляцию, чтобы появился список переменных с таким началом. Найдём переменную `my_div` по началу `my_` и узнаем её значение.

```
> my_div

[1] 3.478505 3.181981 2.146460
```

### Урок №2: Рабочее пространство и файлы

Определим, какой каталог использует текущий сеанс R в качестве текущего рабочего каталога, используя команду `getwd()`.

```
> getwd()

[1] "C:/Users/Юлия/Documents/PZ_sem7_7"
```

Выведем на экран все объекты локальной рабочей среды с помощью команды `ls()`. Так как переменных изначально не было, на экран вывело "character(0)"

```
> ls()

character(0)
```
Назначим 9 в x с помощью команды "x <- 9".

```
> x <- 9
```

Теперь посмотрим на объекты локальной рабочей среды с помощью команды "ls()".

```
> ls()

[1] "x"
```

Выведем на экран все файлы рабочей директории с помощью команд "list.files()" или "dir()".                               

```
> dir()

[1] "pppr_1.html"     "pppr_1.qmd"      "pppr_1_files"    "PZ_1"           
[5] "PZ_1.md"         "PZ_sem7_2.Rproj" "README.md"       "testdir"  
```

Попробуем функцию вызова информации по команде `list.files`.

```
> ?list.files
```

Используя функцию `args()` мы можем узнать какие аргументы даёт введёная в скобках функция. Посмотрим аргументы команды `list.files()`

```
> args(list.files)
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
NULL
```

Зададим в переменную `old.dir` нашу рабочую директорию. Это нужно, чтобы в конце к ней вернуться.

```
> old.dir <- getwd()
```

С помощью команды `dir.create()` создадим новый директорий с именем `testdir` в уже существующий. Так как он был создан ранее, то программа выдаст предупреждение.

```
> dir.create("testdir")

Warning message:
In dir.create("testdir") : `testdir` already exists
```

Чтобы работать в этой директории, надо задать её как рабочую с помощью команды `setwd()`.

```
> setwd("testdir")
```

Создадим файл `mytest.R`, используя функцию `file.create()`.

```
> file.create("mytest.R")

[1] TRUE
```

Проверим, какие файлы у нас лежат в новой директории.

```
> dir()

[1] "mytest.R"
```

Чтобы проверить, существует ли `mytest.R` в рабочей директории, используем команду `file.exists()`.

```
> file.exists("mytest.R")

[1] TRUE
```

Посмотрим информацию о файле `mytest.R`, используя команду `file.info()`.

```
> file.info("mytest.R")

         size isdir mode               mtime               ctime
mytest.R    0 FALSE  666 2023-09-30 11:36:47 2023-09-28 15:47:09
                       atime exe
mytest.R 2023-09-30 11:36:47  no
```

Переименуем файл `mytest.R` в `mytest2.R`, используя команду `file.rename()`.

```
> file.rename("mytest.R", "mytest2.R")

[1] TRUE
```

Сделаем копию файла `mytest2.R` и назовём копию `mytest3.R`, используя команду `file.copy()`.

```
> file.copy("mytest2.R", "mytest3.R")

[1] TRUE
```

Укажите родительский путь к файлу `mytest3.R`, используя команду `file.path()`.

```
> file.path("mytest3.R")

[1] "mytest3.R"
```

Можно использовать `file.path()` для построения путей к файлам и каталогам, которые не зависят от операционной системы, в которой выполняется наш R-код. Передадим `folder1` и `folder2` в качестве аргументов для создания независимого от платформы имени пути.

```
> file.path("folder1", "folder2")

[1] "folder1/folder2"
```

Посмотрим документацию команды `dir.create` с помощью вопросительного знака.

```
> ?dir.create
```

Создадим новый директорий в нашей рабочей директории и назовём его `testdir2`, а также создадим сабдиректорий и назовём его `testdir3`, используя только команды `dir.create()` и `file.path()`.

```
> dir.create(file.path(`testdir2`, `testdir3`), recursive = TRUE)
```

Вернёмся обратно в рабочую директорию на компьютере, с помощью команды `setwd()`. Вспомним, что ранее мы заносили её в переменную `old.dir`.

```
> setwd(old.dir)
```

### Урок №3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать оператор `:`. Введём `1:20`, чтобы увидеть как это работает.

```
> 1:20

 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
```

Также мы можем создать последовательность из вещественных чисел. Для этого используем команду `pi:10`, чтобы создать последовательность от числа Пи.

```
> pi:10

[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593
```

Если поменять цифры местами, то получится обратный список последовательности чисел. Попробуем перевернуть список с помощью команды `15:1`.

```
> 15:1

 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
```

Важно помнить, что при запросе документации по оператору, его необходимо заключить в ``подобные`` кавычки. Попробуем узнать информацию об операторе `?`.

```
> ?`:`
```

Существует операция `seq()`, аналогичная оператору `:`. Убедимся в этом с помощью команды `seq(1, 20)`.

```
> seq(1, 20)

 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
```

Можно задать последовательность чисел и указать шаг, на который будет сдвигаться генерация чисел. Создадим последовательность от 0 до 10 с шагом 0.5 с помощью команды `seq(0, 20, by=0.5)`.

```
> seq(0, 10, by=0.5)

 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5
[15]  7.0  7.5  8.0  8.5  9.0  9.5 10.0
```

Если нас не волнует, какое приращение задано и мы просто хотим создать последовательность от 5 до 10, которое включает в себя 30 элементов. Создадим данную последовательность через команду `seq(5, 10, length=30)` и занесём её в переменную `my_seq`.

``` 
> my_seq <- seq(5, 10, length=30)
```

Чтобы убедиться, что последовательность имеет длину 30, ипользуем команду `length()`.

```
> length(my_seq)

[1] 30
```

Теперь посмотрим как мы можем комбинировать команды между собой. Используем значение длины 30 и попробуем задать последовательность `1:30` с использованием команды `length(my_seq)`.

```
> 1:length(my_seq)

 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25 26 27 28 29 30
```

Есть и другой вариант использования данной конструкции, используя функцию `along.with`, которая берет длину из длины аргумента (замена length()).

```
> seq(along.with = my_seq)

 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25 26 27 28 29 30
```
Однако, как и в случае со многими распространенными задачами, R имеет отдельную встроенную функцию для этой цели, называемую `seq_along()`. Она составляет на основе длины последловательности свою собственную.

```
> seq_along(my_seq)

 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
[24] 24 25 26 27 28 29 30
```

Также существует функция повторения числа или вектора n-ное количество раз. Создадим вектор, который содержит в себе 40 нулей с помощью команды `rep(0, times = 40)`.

```
> rep(0, times = 40)

 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[36] 0 0 0 0 0
```

Посмотрим как эта же функция можем справиться с векторами, созданными через функцию `c(0, 1, 2)`. Повторим её 10 раз с помощью команды `rep(c(0, 1, 2), times = 10)`.

```
> rep(c(0, 1, 2), times = 10)

 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2
```

Стоит отметить, что если нам требуется повторить каждый элемент, то на помощь придёт функция `each()`. Попробуем повторить 10 раз каждый из элементов вектора `c(0, 1, 2)` с помощью команды `rep(c(0, 1, 2), each = 10)`.

```
> rep(c(0, 1, 2), each = 10)

 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2
```

### Векторы

Начнём с создания вектора чисел, который содержит значения `0.5`, `55`, `-10`, `6` и занесён в переменную `num_vect`.

```
> num_vect <- c(0.5, 55, -10, 6)
```

Далее создадим новую переменную `tf` и дадим ей значение результата `num_vect < 1`. В итоге мы получим вектор, содержащий 4 логических значения [TRUE | FALSE]

```
> tf <- num_vect < 1
```

Выведем на экран значение переменной `tf`.

```
> tf

[1]  TRUE FALSE  TRUE FALSE
```

Далее выведем на экран результат работы команды `num_vect >= 6` без занесения в переменную.

```
> num_vect >= 6

[1] FALSE  TRUE FALSE  TRUE
```

Далее необходимо пройти мини-тест, содержащий в себе 2 варианта ответа.

***Вопрос №1.***\n
(3 > 5) & (4 == 4)\n
FALSE & TRUE = FALSE\n

*Ответ:* FALSE\n


| (TRUE == TRUE) | (TRUE == FALSE)

1: FALSE
2: TRUE

Выбор:2

| That's correct!

  |================================                                    |  47%
| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

1: TRUE
2: FALSE

Выбор:2

| Nice try, but that's not exactly what I was hoping for. Try again.

| This is a tricky one. Remember that the `!` symbol negates whatever comes
| after it. There's also an 'order of operations' going on here. Conditions
| that are enclosed within parentheses should be evaluated first. Then, work
| your way outwards.

1: FALSE
2: TRUE

Выбор:2

| Perseverance, that's the answer.

  |==================================                                  |  50%
| Don't worry if you found these to be tricky. They're supposed to be.
| Working with logical statements in R takes practice, but your efforts will
| be rewarded in future lessons (e.g. subsetting and control structures).

...

  |====================================                                |  53%
| Character vectors are also very common in R. Double quotes are used to
| distinguish character objects, as in the following example.

...

  |======================================                              |  55%
| Create a character vector that contains the following words: "My", "name",
| "is". Remember to enclose each word in its own set of double quotes, so
| that R knows they are character strings. Store the vector in a variable
| called my_char.

> my_char <- c("My", "name", "is")

| That's correct!

  |=======================================                             |  58%
| Print the contents of my_char to see what it looks like.

> my_char
[1] "My"   "name" "is"  

| That's correct!

  |=========================================                           |  61%
| Right now, my_char is a character vector of length 3. Let's say we want to
| join the elements of my_char together into one continuous character string
| (i.e. a character vector of length 1). We can do this using the paste()
| function.

...

  |===========================================                         |  63%
| Type paste(my_char, collapse = " ") now. Make sure there's a space between
| the double quotes in the `collapse` argument. You'll see why in a second.

> paste(my_char, collapse = " ")
[1] "My name is"

| Perseverance, that's the answer.

  |=============================================                       |  66%
| The `collapse` argument to the paste() function tells R that when we join
| together the elements of the my_char character vector, we'd like to
| separate them with single spaces.

...

  |===============================================                     |  68%
| It seems that we're missing something.... Ah, yes! Your name!

...

  |================================================                    |  71%
| To add (or 'concatenate') your name to the end of my_char, use the c()
| function like this: c(my_char, "your_name_here"). Place your name in double
| quotes where I've put "your_name_here". Try it now, storing the result in a
| new variable called my_name.

> my_name <- c(my_char, "Yuliya")

| Excellent job!

  |==================================================                  |  74%
| Take a look at the contents of my_name.

> my_name
[1] "My"     "name"   "is"     "Yuliya"

| You are quite good my friend!

  |====================================================                |  76%
| Now, use the paste() function once more to join the words in my_name
| together into a single character string. Don't forget to say collapse = "
| "!

> paste(my_char, collapse = " ")
[1] "My name is"

| Almost! Try again. Or, type info() for more options.

| Use paste(my_name, collapse = " ") to join all four words together,
| separated by single spaces.

> paste(my_name, collapse = " ")
[1] "My name is Yuliya"

| Excellent work!

  |======================================================              |  79%
| In this example, we used the paste() function to collapse the elements of a
| single character vector. paste() can also be used to join the elements of
| multiple character vectors.

...

  |=======================================================             |  82%
| In the simplest case, we can join two character vectors that are each of
| length 1 (i.e. join two words). Try paste("Hello", "world!", sep = " "),
| where the `sep` argument tells R that we want to separate the joined
| elements with a single space.

> paste("Hello", "world!", sep = " ")
[1] "Hello world!"

| You got it!

  |=========================================================           |  84%
| For a slightly more complicated example, we can join two vectors, each of
| length 3. Use paste() to join the integer vector 1:3 with the character
| vector c("X", "Y", "Z"). This time, use sep = "" to leave no space between
| the joined elements.

> paste(1:3, c("X","Y","Z"), sep = "")
[1] "1X" "2Y" "3Z"

| You got it right!

  |===========================================================         |  87%
| What do you think will happen if our vectors are of different length?
| (Hint: we talked about this in a previous lesson.)

...

  |=============================================================       |  89%
| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a
| predefined variable in R containing a character vector of all 26 letters in
| the English alphabet.

> paste(A:Z, 1:4, sep = "-")
Error in paste(A:Z, 1:4, sep = "-") : object 'A' not found
> paste("A":"Z", 1:4, sep = "-")
Error in "A":"Z" : NA/NaN argument
In addition: Warning messages:
1: In paste("A":"Z", 1:4, sep = "-") : NAs introduced by coercion
2: In paste("A":"Z", 1:4, sep = "-") : NAs introduced by coercion
> paste(с("A", "B", "C", "D", "E", "F", "G", "H", "I", "G", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"), 1:4, sep = "-")
Error in с("A", "B", "C", "D", "E", "F", "G", "H", "I", "G", "K", "L",  : 
  could not find function "с"
> paste(c("A", "B", "C", "D", "E", "F", "G", "H", "I", "G", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"), 1:4, sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "G-2" "K-3" "L-4"
[13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
[25] "Y-1" "Z-2"

| Not quite! Try again. Or, type info() for more options.

| Type paste(LETTERS, 1:4, sep = "-") to see how R recycles the vector 1:4 to
| match the length of LETTERS. Notice we are using `-` as our separator this
| time instead of a single space.

> paste(c("L", "E", "T", "T", "E", "R", "S"), 1:4, sep = "-")
[1] "L-1" "E-2" "T-3" "T-4" "E-1" "R-2" "S-3"

| You're close...I can feel it! Try it again. Or, type info() for more
| options.

| Type paste(LETTERS, 1:4, sep = "-") to see how R recycles the vector 1:4 to
| match the length of LETTERS. Notice we are using `-` as our separator this
| time instead of a single space.

> paste(LETTERS, 1:4, sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4"
[13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
[25] "Y-1" "Z-2"

| You're the best!

  |===============================================================     |  92%
| Since the character vector LETTERS is longer than the numeric vector 1:4, R
| simply recycles, or repeats, 1:4 until it matches the length of LETTERS.

